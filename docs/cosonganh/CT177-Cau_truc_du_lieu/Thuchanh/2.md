# <img src="https://raw.githubusercontent.com/Zenfection/Image/master/2020/12/16-23-16-51-icons8-link.png" width="40"> B√†i 2. Danh s√°ch li√™n k·∫øt

## <img src="https://raw.githubusercontent.com/Zenfection/Image/master/2021/05/08-10-31-59-icons8_handle_with_care_35px.png"> M√¥ h√¨nh 

::: tip üí° M·∫∏O

B·∫°n c√≥ th·ªÉ tham kh·∫£o v√† th·ª±c h√†nh theo m√¥ h√¨nh `Linked List` [t·∫°i ƒë√¢y](https://visualgo.net/en/list)
:::

## <img src="https://raw.githubusercontent.com/Zenfection/Image/master/2021/05/08-10-30-52-icons8_concept_30px.png">[L√Ω thuy·∫øt](https://nguyenvanhieu.vn/danh-sach-lien-ket-don/)


## <img src="https://raw.githubusercontent.com/Zenfection/Image/master/2021/05/08-10-24-29-icons8_google_code_30px.png"> Source Code

### [linkedList.h](https://github.com/Zenfection/zenctu/blob/main/docs/cosonganh/CT177-Cau_truc_du_lieu/Source/LinkedList/linkedList.h)

::: tip C·∫§U TR√öC

```c
struct NODE{
    int data;
    struct NODE* Next;
};
typedef struct NODE Node;
typedef struct{
    Node *Head;
    Node *Tail;
    int Size;
}List;
```
:::

::: tip KH·ªûI T·∫†O R·ªñNG

```c
void makeNullList(List *L){
    L->Head = NULL;
    L->Tail = NULL;
    L->Size = 0;
}
```
:::

::: tip HI·ªÇN TH·ªä DANH S√ÅCH

```c
void displayList(List L){
    Node *temp = L.Head;
    while(temp != NULL){
        printf("%d ",temp->data);
        temp = temp->Next;
    }
    printf("\n");
    printf("Size = %d",L.Size);
    printf("\n");
}
```
:::

::: tip T·∫†O M·ªòT NODE V·ªöI PH·∫¶N T·ª¨

```c
Node *createNode(int x){
    Node *newnode = (Node *)malloc(sizeof(Node));
    newnode->data = x;
    newnode->Next = NULL;
    return newnode;
}
```
:::

::: tip TH√äM NODE V√ÄO ƒê·∫¶U HO·∫∂C CU·ªêI DANH S√ÅCH

```c
void insertList_Frist(Node *newNode,List *L){
    if(L->Head == NULL){
        L->Head = newNode;
        L->Tail = newNode;
    }
    else{
        newNode->Next = L->Head;
        L->Head = newNode;
    }
    L->Size++;
}

void insertList_End(Node *newNode,List *L){
    if(L->Head == NULL){
        L->Head = newNode;
        L->Tail = newNode;
    }
    else{
        L->Tail->Next = newNode;
        L->Tail=newNode;
        newNode->Next = NULL;
    }
    L->Size++;
}
```
:::

::: tip TH√äM NODE V√ÄO V·ªä TR√ç P TRONG DANH S√ÅCH

```c
void insertList_byPos(int p,Node *newNode,List *L){
    if(p < 1 || L->Head == NULL){
        insertList_Frist(newNode,L);
    }
    else if(p >= L->Size){
        insertList_End(newNode,L);
    }
    else{
        Node *temp = L->Head;
        int i = 0;
        while(temp != NULL){
            if(p - 1 == i){
                newNode->Next = temp->Next;
                temp->Next = newNode;
                L->Size++;
                return;
            }
            i++;
            temp = temp->Next;
        }
    }
}
```
:::

::: tip TH√äM N NODE V√ÄO DANH S√ÅCH

```c
void inputList(int n,List *L){
    int x;
    Node *temp;
    for (int i = 0; i < n; i++){
        scanf("%d",&x);
        temp = createNode(x);
        insertList_byPos(i,temp,L);
    }
}
```
:::

::: tip KI·ªÇM TRA X TRONG DANH S√ÅCH

```c
int memberList(int x,List L){
    Node *temp = L.Head;
    while (temp != NULL){
        if(temp->data == x){
            return 1;
        }
        temp = temp->Next;
    }
    return 0;
}
```
:::

::: tip T√åM V·ªä TR√ç NODE CH·ª®A X

```c
int locateList(int x,List L){
    Node *temp = L.Head;
    int i = 0;
    while (temp != NULL){
        if(temp->data = x){
            free(temp);
            return i;
        }
        else{
            i++;
        }
        temp = temp->Next;
    }
    free(temp);
    return -1;
}
```
:::

::: tip XO√Å NODE C√ì V·ªä TR√ç P TRONG DANH S√ÅCH

```c
void deleteList_byPos(int p,List *L){
    Node *temp = L->Head;
    Node *prev = NULL;
    int i = 0;
    while (temp != NULL) {
        if(p == i){
            if (prev==NULL) {
                L->Head=temp->Next;
            }
            else{
                prev->Next=temp->Next;
            }
            L->Size--;
            return;
        }
        else{
            i++;
        }
        prev = temp;
        temp = temp->Next;
    }
}
```
:::

::: tip XO√Å NODE TRONG DANH S√ÅCH

```c
void deleteList_byNode(Node* newNode,List *L){
    int i = 0;
    Node *temp = L->Head;
    while (temp != NULL){
        if(newNode == temp){
            deleteList_byPos(i,L);
        }
        else{
            i++;
        }
        temp = temp->Next;
    }
}
```
:::

::: tip XO√Å NODE C√ì PH·∫¶N T·ª¨ X TRONG DANH S√ÅCH

```c
void deleteList_byValue(int x,List *L){
    Node *temp = L->Head;
    int i = 0;
    while (temp != NULL){
        if(temp->data == x){
            deleteList_byPos(i,L);
        }
        else{
            i++;
        }
        temp = temp->Next;
    }
}
```
:::

::: tip T·ªêI ∆ØU DANH S√ÅCH (`1 2 1` -> `1 2`)

```c
void optimizeList(List *L){
    Node *temp1 = L->Head;
    Node *temp2 = NULL;
    while (temp1->Next != NULL){
        temp2 = temp1->Next;
        while (temp2 != NULL){
            if(temp1->data == temp2->data){
                deleteList_byNode(temp2,L);
            }
            temp2 = temp2->Next;
        }
        temp1 = temp1->Next;
    }
}
```
:::

::: tip T√åM NODE C√ì PH·∫¶N T·ª¨ L·ªöN NH·∫§T HO·∫∂C NH·ªé NH·∫§T

```c
int Find_Max(List L){
    Node *temp=L.Head;
    int max=temp->data;
    while (temp!=NULL) {
        if(max<temp->data){
            max=temp->data;
        }
        temp=temp->Next;
    }
    free(temp);
    return max;
}

int Find_Min(List L){
    Node *temp=L.Head;
    int min=temp->data;
    while (temp!=NULL) {
        if(min>temp->data){
            min=temp->data;
        }
        temp=temp->Next;
    }
    free(temp);
    return min;
}
```
:::

::: tip CHUY·ªÇN SANG DANH S√ÅCH KH√ÅC 

```c
void changeList(List L1,List *L){
    Node *temp = L1.Head;
    int i = L->Size;
    while (temp != NULL){
        insertList_byPos(i,createNode(temp->data),L);
        i++;
        temp = temp->Next;
    }
}
```
:::

::: tip G·ªòP 2 DANH S√ÅCH TH√ÄNH 1 DANH S√ÅCH 

```c
void mergeList(List L1,List L2,List *L){
    changeList(L1,L);
    changeList(L2,L);
}
```
:::

::: tip L·ªåC S·ªê CH·∫¥N HO·∫∂C L·∫∫ QUA DANH S√ÅCH KH√ÅC

```c
void filter_evenNumber(List L1, List *L){
    Node *temp = L1.Head;
    int i = L->Size;
    while (temp != NULL){
        if(temp->data % 2 == 0){
            insertList_byPos(i,createNode(temp->data),L);
        }
        i++;
        temp = temp->Next;
    }
}

void filter_oddNumber(List L1, List *L){
    Node *temp = L1.Head;
    int i = L->Size;
    while (temp != NULL){
        if(temp->data % 2 != 0){
            insertList_byPos(i,createNode(temp->data),L);
        }
        i++;
        temp = temp->Next;
    }
}
```
:::

::: tip T√çNH T·ªîNG TRUNG B√åNH PH·∫¶N T·ª¨ TRONG DANH S√ÅCH

```c
double averageList(List L){
    Node *temp = L.Head;
    double result = 0;
    while (temp != NULL){
        result += temp->data;
        temp = temp->Next;
    }
    return result/L.Size;
}
```
:::

### [sentenceList.h](https://github.com/Zenfection/zenctu/blob/main/docs/cosonganh/CT177-Cau_truc_du_lieu/Source/LinkedList/sentenceList.h)

::: tip C·∫§U TR√öC

```c
struct NODE{
    char Word;
    struct NODE *Next;
};
typedef struct NODE Node;
typedef struct{
    Node *Head;
    Node *Tail;
    int Size;
}Sentence;
```
:::

::: tip T·∫†O R·ªñNG C√ÇU

```c
void makeNullSentence(Sentence *S){
    S->Head = NULL;
    S->Tail = NULL;
    S->Size = 0;
}
```
:::

::: tip HI·ªÇN TH·ªä C√ÇU

```c
void displaySentence(Sentence S){
    Node *temp = S.Head;
    while(temp != NULL){
        printf("%c",temp->Word);
        temp = temp->Next;
    }
    printf("Size = %d",S.Size);
    printf("\n");
}
```
:::

::: tip T·∫†O M·ªòT NODE X L√Ä T·ª™

```c
Node *createNode(char c){
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->Word = c;
    newNode->Next = NULL;
    return newNode;
}
```
:::

::: tip CH√àN M·ªòT T·ª™ V√ÄO ƒê·∫¶U HO·∫∂C CU·ªêI C√ÇU

```c
void insertSentence_Frist(Node *newNode,Sentence *S){
    if(S->Head == NULL){
        S->Head = newNode;
        S->Tail = newNode;
    }
    else{
        newNode->Next = S->Head;
        S->Head = newNode;
    }
    S->Size++;
}
void insertSentence_End(Node *newNode,Sentence *S){
    if(S->Head == NULL){
        S->Head = newNode;
        S->Tail = newNode;
    }
    else{
        S->Tail->Next = newNode;
        S->Tail=newNode;
        newNode->Next = NULL;
    }
    S->Size++;
}
```
:::

::: tip CH√àN T·ª™ V·ªä TR√ç P TRONG C√ÇU 

```c
void insertSentence_byPos(int p,Node *newNode,Sentence *S){
    if(p < 1 || S->Head == NULL){
        insertSentence_Frist(newNode,S);
    }
    else if(p >= S->Size){
        insertSentence_End(newNode,S);
    }
    else{
        Node *temp = S->Head;
        int i = 0;
        while(temp != NULL){
            if(p - 1 == i){
                newNode->Next = temp->Next;
                temp->Next = newNode;
                S->Size++;
                return;
            }
            i++;
            temp = temp->Next;
        }
    }
}
```
:::

::: tip NH·∫¨P C√ÇU

```c
void inputSentence(Sentence *S){
    char c[100];
    fgets(c,100,stdin);
    int len = strlen(c);
    Node *temp;
    for(int i = 0 ; i < strlen(c) ; i++){
        temp = createNode(c[i]);
        insertSentence_byPos(i,temp,S);
    }
}
```
:::

::: tip KI·ªÇM TRA T·ª™ X C√ì TRONG C√ÇU

```c
int memberSentence(char x,Sentence S){
    Node *temp = S.Head;
    while (temp != NULL){
        if(temp->Word == x){
            return 1;
        }
        temp = temp->Next;
    }
    return 0;
}
```
:::

::: tip T√åM V·ªä TR√ç T·ª™ X TRONG C√ÇU

```c
int locateSentence(char x,Sentence S){
    Node *temp = S.Head;
    int i = 0;
    while (temp != NULL){
        if(temp->Word == x){
            return i;
        }
        else{
            i++;
        }
        temp = temp->Next;
    }
    return -1;
}
```
:::

::: tip XO√Å T·ª™ V·ªä TR√ç P TRONG C√ÇU

```c
void deleteSentence_byPos(int p,Sentence *S){
    Node *temp = S->Head;
    Node *prev = NULL;
    int i = 0;
    while (temp != NULL) {
        if(p == i){
            if (prev==NULL) {
                S->Head=temp->Next;
            }
            else{
                prev->Next=temp->Next;
            }
            S->Size--;
            return;
        }
        else{
            i++;
        }
        prev = temp;
        temp = temp->Next;
    }
}
```
:::

::: tip XO√Å T·ª™ X TRONG C√ÇU

```c
void deleteSentence_byValue(char x,Sentence *S){
    Node *temp = S->Head;
    int i = 0;
    while (temp != NULL){
        if(temp->Word == x){
            deleteSentence_byPos(i,S);
        }
        else{
            i++;
        }
        temp = temp->Next;
    }
}
```
:::

::: tip  XO√Å M·ªòT NODE  TRONG C√ÇU

```c
void deleteSentence_byNode(Node *newNode,Sentence *S){
    int i = 0;
    Node *temp = S->Head;
    while (temp != NULL){
        if(newNode == temp){
            deleteSentence_byPos(i,S);
        }
        else{
            i++;
        }
        temp = temp->Next;
    }
}
```
:::

::: tip XO√Å KHO·∫¢NG TR·∫ÆNG D∆Ø TH·ª™A

```c
void deleteWhiteSpace(Sentence *S){
    Node *temp = S->Head;
    while(isspace(temp->Word)){
        deleteSentence_byNode(temp,S);
        temp = temp->Next;
    }
    while(temp != NULL){
        if(isspace(temp->Word) && temp->Next != NULL){
            if(isspace(temp->Next->Word)){
                deleteSentence_byNode(temp,S);
            }
        }
        temp = temp->Next;
    }
}
```
:::

::: tip CHU·∫®N HO√Å C√ÇU

```c
void normalizeSentence(Sentence *S){
    deleteWhiteSpace(S);
    Node *temp = S->Head;
    if(islower(temp->Word)){
        temp->Word -= 32;
    }
    temp = temp->Next;
    while (temp != NULL){
        while(!isspace(temp->Word)){
            if(isupper(temp->Word)){
                temp->Word += 32;
            }
            temp = temp->Next;
        }
        if(isspace(temp->Word) && temp->Next != NULL){
            temp = temp->Next;
            if(islower(temp->Word)){
                temp->Word -= 32;
            }
        }
        temp = temp->Next;
    }
}

```
:::

<comment/>
