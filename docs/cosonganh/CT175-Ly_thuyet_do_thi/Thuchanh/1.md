# Bài thực hành 1

Trong bài này bạn cần nắm bắt các mục như sau : 

> - Khai báo cấu trúc đồ thị (chủ yếu ma trận đỉnh cung)
> 
> - Các hàm cơ bản đồ thị như nhập cung
>
> - Tính bậc của 1 đỉnh trong đồ thị
>
> - Danh sách đỉnh kề của 1 đỉnh

::: tip 💡 THƯ VIỆN

Sử dụng các thư viện sau:

```c:no-line-numbers
#include <stdio.h>    // thư viện cơ bản của C
#include <stdbool.h>  // hỗ trợ true/false cho C
#include "list.h"     // thư viện cá nhân hỗ trợ danh sách
```
:::

::: warning ⚠️ LƯU Ý

Tất cả các đỉnh trong đồ thị bắt đầu từ `1` thay vì `0`, nên hãy để ý rõ không thì sai !!!
:::

> Download thư viện [list.h]()

## Cấu trúc đồ thị

### Danh sách đỉnh cung

```c
#define MAX_VERTEX 50 
typedef struct{
    int A[MAX_VERTEX][MAX_VERTEX];
    int n; //số đỉnh
    int m; //số cung
}Graph;
```

### Danh sách cung

```c
#define MAX 50

typedef struct {
    int u, v;
    int w;
} Edge;
typedef struct {
    int n, m;
    Edge edges[MAX];
} Graph;
```

## Các hàm thao tác đồ thị

### Hàm nhập cơ bản

```c
void makeNullGraph(Graph *G){ //khởi tạo đồ thị rỗng
    G->m = 0;
    G->n = 0;
}

void init_Graph(Graph *G, int n){ //khởi tạo đồ thị với n đỉnh
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            G->A[i][j] = 0;
}

void add_edge(Graph *G, int x, int y){    //thêm 1 cung vào đồ thị
    if(G->A[x][y] == 1 && G->A[x][y] == 1) //trường hợp đa cung
        G->A[x][y] = G->A[y][x] = 2;
    else
        G->A[x][y] = G->A[y][x] = 1;
}

void add_edgeDirection(Graph *G, int x,int y){ // thêm 1 cung cho đồ thị có hướng
    G->A[x][y] = 1;
}

void printGraph(Graph G){ // in ma trận đồ thị 
    for (int i = 1; i <= G.n; i++){
        for (int j = 1; j <= G.n; j++){
            printf("%d ",G.A[i][j]);
        }
        printf("\n");
    }
}
```

::: warning ⚠️ LƯU Ý

Hàm thêm cung tuỳ thuộc vào hoàn cảnh bài toán mà bạn sửa lại cho đúng.
:::

### Hàm thao tác cơ bản

```c
int degree(Graph G, int x){ // tính bậc của đỉnh
    int count = 0;
    for (int i = 1; i <= G.n; i++)
        if(G.A[x][i] == 1)
            count++;
    return count;
}
List neighbors(Graph G, int x){ // trả về danh sách các đỉnh kề
    List L; 
    makeNullList(&L);
    for (int i = 1; i <= G.n; i++)
        if(G.A[x][i] == 1){
            insertList(i,&L);
    return L;
}
List arrayGraph(Graph G){ // trả về danh sách các đỉnh trong đồ thị
    List L;
    makeNullList(&L);
    for (int i = 1; i <= G.n; i++)
        insertList(i,&L);
    return L;
}
```

### Các hàm xử lý đồ thị

```c
bool multiEdge(Graph G){  // kiểm tra có chứa đa cung không
    for (int i = 1; i <= G.n; i++)
        for (int j = 0; j <= G.n; j++)
            if(G.A[i][j] > 1) // hoặc = 2 đều được
                return true;
            
    return false;
}

int maxDegree(Graph G){
    int max = degree(G,1);
    for(int i = 2; i <= G.n; i++){
        int x = degree(G,i);
        if(max < x)
            max = x;
    }
    return x;
}
```


<comment/>
