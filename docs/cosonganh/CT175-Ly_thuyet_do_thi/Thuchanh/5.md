# Bài thực hành 5

## Giải thuật `Prim`

> Sử dụng cho danh sách đỉnh đỉnh

::: tip 

| Đầu vào                  | Đầu ra                      | Thay đổi   |
| ------------------------ | --------------------------- | ---------- |
| Đồ thị `G`<br>Đồ thị `T` | chi phí cây khung ngắn nhât | Đồ thị `T` |

:::

```c
int prim(Graph G, Graph *T){
    int cost[MAX], parrent[MAX];
    bool mark[MAX];

    init_Graph(T, G.n);
    int sumW = 0;
    for(int i = 1; i <= G.n; i++){
        cost[i] = 999;
        mark[i] = false;
        if(G.A[1][i]){
            cost[i] = G.A[1][i];
            parrent[i] = 1;
        }
    }

    cost[1] = 0; // có thể thay đổi
    mark[1] = true;

    for(int i = 1; i < G.n; i++){
        int min_dist = 999;
        int min_u;
        for(int j = 1; j <= G.n; j++){
            if(!mark[j]){
                if(min_dist > cost[j]){
                    min_dist = cost[j];
                    min_u = j;
                }
            }
        }
        int u = min_u; //đánh dấu pi[u] nhỏ nhất
        mark[min_u] = true;
        add_edgeDirection(T, parrent[min_u], min_u, min_dist);
        sumW += min_dist;

        // cập nhật lại pi và p của đỉnh kề với u
        for(int v = 1; v <= G.n; v++){
            if(!mark[v]){
                if(G.A[u][v])
                    if(cost[v] > G.A[u][v]){
                        cost[v] = G.A[u][v];
                        parrent[v] = u;
                    }
            }
        }
    }
    return sumW;
}
```
## Giải thuật ``

> Sử dụng cho `danh sách cung`

```c

```
